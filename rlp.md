RLP编码算法: 
 1 单字节值在[0x00,0x7f]之间的,编码就是自身即0-127.这里面需要注意的是0x7f这个边界，
 因为ASCII编码最大值就是0x7f，也就是说在0x7f以内完全当做ASCII编码使用
 
 2 如果一个string长度在0-55之间,则这样进行编码：第1个字节为 0x80+(string的长度) 得到一个相加后的值,
 后面跟着string。由于被编码的字符串最大长度是55=0x37,因此单字节前缀的最大值是0x80+0x37=0xb7，即编码的第一个字节的取值范围是[0x80, 0xb7]
举例：字符串 "test" = [0x84, 't', 'e', 's','t' ] 

3 如果一个string长度超过了55个字节,编码结果的第1个字节为后边表达式的相加取值：0xb7+string的长度值(二进制形式的字节长度) ,
后跟着string的长度,后跟着string。编码的第一个字节即前缀的取值范围是[0xb8, 0xbf]。例如：一个字符串的长度是1023 它的二进制形式是 0011 1111 1111，
这个二进制形式的占用的空间是2个字节，
所以前缀应该是0xb7+2=0xb9，字符串长度1023=0x3FF，因此整个RLP编码应该是\xb9\x03\xFF再跟上字符串本身,
例子2：Lorem ipsum dolor sit amet, consectetur adipisicing elit 这个字符串长度56，二进制是0011 1000，占用1个字节，所以最后是
[0xb8,0x38,'L', 'o', 'r', 'e', 'm', ' ', ... , 'e', 'l', 'i', 't']

4 如果一个列表(数组)的总长度（列表的总长度指的是它包含的项的数量加它包含的各项的长度之和）是0-55字节，它的RLP编码包含一个单字节的前缀，
后面跟着列表中各元素项的RLP编码，这个前缀的值是0xc0加上列表的总长度。编码的第一个字节的取值范围是[0xc0, 0xf7]。

5 如果一个列表的总长度大于55字节，它的RLP编码包含一个单字节的前缀(前缀的值是0xf7加上列表总长度的二进制形式的字节长度，同规则3，
后面跟着列表的长度(同规则3)，后面再跟着列表中各元素项的RLP编码，编码的第一个字节的取值范围是[0xf8, 0xff]

更多的例子
字符串 "dog" = [ 0x83, 'd', 'o', 'g' ]

列表 [ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]

空字符串 ('null') = [ 0x80 ]

空列表 = [ 0xc0 ]

数字15 ('\x0f') = [ 0x0f ]

数字 1024 ('\x04\x00') = [ 0x82, 0x04, 0x00 ]

The set theoretical representation of two, [ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]

字符串 "Lorem ipsum dolor sit amet, consectetur adipisicing elit" = [ 0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', ... , 'e', 'l', 'i', 't' ]

参考官方wiki:
https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-RLP
